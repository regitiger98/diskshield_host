/* sata hooking
 * Syscall hijacking in 2019
 * Feb 23, 2019
 * root@davejingtian.org
 * https://davejingtian.org
 */
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kallsyms.h>
#include <linux/syscalls.h>
#include <linux/fdtable.h>
//#include <linux/set_memory.h> /* newer kernel version */
//#include <asm/cacheflush.h>	/* kernel 4.4 */
#include <linux/libata.h>

/* SMP handling */
#ifdef X86_64
#define SMP_UPDATE(x) \
	do { \
		unsigned long __cr0; \
		preempt_disable(); \
		__cr0 = read_cr0() & (~X86_CR0_WP); \
		write_cr0(__cr0); \
		x; \
		__cr0 = read_cr0() | X86_CR0_WP; \
		write_cr0(__cr0); \
		preempt_enable(); \
	} while (0)
#elif AARCH64
#define SMP_UPDATE(x) \
	do { \
		preempt_disable(); \
		x; \
		preempt_enable(); \
	} while (0)
#else
#define	SMP_UPDATE(x) \
	do { \
		x; \
	} while (0)
#endif

//DISKSHIELD key table 
//This code should be modified!

typedef struct key_lba_hash_node{
        unsigned long lba;
        unsigned int fd;
        unsigned char cmd;
        double timer;
        //      unsigned long value;
//      unsigned int call;
        struct hlist_node elem;
        struct rcu_head rcu;
}KEY_LBA_HASH;



//asmlinkage long my_enc(DS_PARAM *u_ds_param, char *u_buf, int count);
asmlinkage void my_sata(const struct ata_taskfile *tf, u8 pmp, int is_cmd, u8 *fis);


static unsigned long *sys_call_table;
static unsigned long *ata_tf_to_fis2;
static unsigned long *orig_ata;


//static typeof(sys_read) *orig_read;

//static char *target = "sata hooking-test";
//static char *target_file = "README.md";


static void set_addr_rw(unsigned long _addr)
{
#ifdef X86_64
	unsigned int level;
	pte_t *pte = lookup_address(_addr, &level);

	if (pte->pte &~ _PAGE_RW)
		pte->pte |= _PAGE_RW;
#elif AARCH64
	//set_memory_rw(_addr, 1);
	/* set_memory_X is not exported
	 * but fortunately I dont need it on my board...
	 * https://lxr.missinglinkelectronics.com/linux/arch/arm64/mm/pageattr.c
	 */
	return;
#else
	return;
#endif
}

static void set_addr_ro(unsigned long _addr)
{
#ifdef X86_64
	unsigned int level;
	pte_t *pte = lookup_address(_addr, &level);

	pte->pte = pte->pte &~_PAGE_RW;
#elif AARCH64
	//set_memory_ro(_addr, 1);
	return;
#else
	return;
#endif
}

/*
asmlinkage long my_read(int fd, char __user *buf, size_t count)
{
	unsigned char kbuf[32];

	if (is_target(fd)) {
		pr_info("sata hooking: my_read - intercept target\n");
		memset(kbuf, '7', sizeof(kbuf));
		copy_to_user(buf, kbuf, sizeof(kbuf));
		return sizeof(kbuf);
	}

	
	return orig_read(fd, buf, count);
}
*/
asmlinkage void my_sata(const struct ata_taskfile *tf, u8 pmp, int is_cmd, u8 *fis)
{
        KEY_LBA_HASH* cur_map=NULL;
        unsigned long DS_lba;
        char lba_chk=0;
//      unsigned long value;
//      unsigned int call;
        unsigned int fd;
        unsigned char cmd;

        fis[0] = 0x27;                  /* Register - Host to Device FIS */
        fis[1] = pmp & 0xf;             /* Port multiplier number*/
        if (is_cmd)
                fis[1] |= (1 << 7);     /* bit 7 indicates Command FIS */

        fis[2] = tf->command;
        fis[3] = tf->feature;

        fis[4] = tf->lbal;
        fis[5] = tf->lbam;
        fis[6] = tf->lbah;
        fis[7] = tf->device;

        fis[8] = tf->hob_lbal;
        fis[9] = tf->hob_lbam;
        fis[10] = tf->hob_lbah;
        fis[11] = tf->hob_feature;

        fis[12] = tf->nsect;
        fis[13] = tf->hob_nsect;
        fis[14] = 0;
        fis[15] = tf->ctl;
        fis[16]=0;

        printk("ata_tf_to_fis2 hooked!!\n");
}


static void syscall_hijack(void)
{
	//orig_read = (typeof(sys_read) *)sys_call_table[__NR_read];
	//pr_info("sata hooking: orig sys_read [%x]\n", orig_read);
    orig_ata = ata_tf_to_fis2;

	//set_addr_rw((unsigned long)sys_call_table);
    set_addr_rw((unsigned long)ata_tf_to_fis2);
    SMP_UPDATE({*ata_tf_to_fis2= (void*)&my_sata;});
	//SMP_UPDATE({ata_tf_to_fis2= (void *)&my_sata;});
	//SMP_UPDATE({sys_call_table[__NR_read] = (void *)&my_read;});

}

static void syscall_recover(void)
{
	//SMP_UPDATE({sys_call_table[__NR_read] = (void *)orig_read;});
	set_addr_ro((unsigned long)sys_call_table);
    set_addr_ro((unsigned long)ata_tf_to_fis2);
    ata_tf_to_fis2 = (void *)kallsyms_lookup_name("ata_tf_to_fis");
//    SMP_UPDATE({*ata_tf_to_fis2 =*orig_ata;});
	SMP_UPDATE({*ata_tf_to_fis2 = orig_ata;});
//	SMP_UPDATE({ata_tf_to_fis2 = orig_ata;});
}



static int __init sata_init(void)
{
	pr_info("sata hooking: Entering: %s\n", __func__);
/*
	sys_call_table = (void *)kallsyms_lookup_name("sys_call_table");
	if (!sys_call_table) {
		pr_err("sata hooking: Couldn't look up sys_call_table\n");
		return -1;
	}
	pr_info("sata hooking: sys_call_table [%x]\n", sys_call_table);
*/
    ata_tf_to_fis2 = (void *)kallsyms_lookup_name("ata_tf_to_fis");
    if (!ata_tf_to_fis2) {
		pr_err("sata hooking: Couldn't look up ata_tf_to_fis2 symbol\n");
		return -1;
	}

#ifdef X86_64
	pr_info("sata hooking: arch x86_64\n");
#elif AARCH64
	pr_info("sata hooking: arch aarch64\n");
#else
	pr_info("sata hooking: arch unsupported\n");
#endif
	syscall_hijack();

	return 0;
}

static void __exit sata_exit(void)
{
	pr_info("sata hooking: exiting sata hooking module\n");
	syscall_recover();
}

module_init(sata_init);
module_exit(sata_exit);

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("sata hooking module");
MODULE_AUTHOR("daveti");
